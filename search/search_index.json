{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bijux-rar","text":"<p>bijux-rar is a deterministic retrieval-augmented reasoning (RAR) engine.</p> <p>It produces byte-stable traces, versioned artifacts, and verifiable provenance for every run. Execution, verification, and replay are first-class constraints, not optional features.</p>"},{"location":"#why-this-exists","title":"Why this exists","text":"<p>Most RAG / RAR systems are: - non-deterministic, - impossible to replay, - unverifiable after the fact, - dependent on trust in the author or runtime.</p> <p>bijux-rar enforces: - deterministic execution, - immutable artifacts, - cryptographically stable traces, - replay and verification by default.</p> <p>If a run cannot be replayed and verified byte-for-byte, it is considered invalid.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install bijux-rar\n````\n\nPython \u2265 3.10 is required.\n\n---\n\n## Minimal usage\n\n### CLI\n\n```bash\nbijux-rar run \\\n  --spec examples/spec.json \\\n  --artifacts-dir artifacts/runs \\\n  --seed 0\n\nRUN_DIR=$(cat artifacts/runs/latest.txt 2&gt;/dev/null || ls artifacts/runs | head -n1)\n\nbijux-rar verify \\\n  --trace artifacts/runs/$RUN_DIR/trace.jsonl \\\n  --plan artifacts/runs/$RUN_DIR/plan.json \\\n  --fail-on-verify\n\nbijux-rar replay \\\n  --trace artifacts/runs/$RUN_DIR/trace.jsonl \\\n  --fail-on-diff\n</code></pre> <p>Verification or replay failures indicate invariant violations.</p>"},{"location":"#http-api","title":"HTTP API","text":"<pre><code>uvicorn bijux_rar.httpapi:app --host 127.0.0.1 --port 8000\n</code></pre> <pre><code>curl -X POST http://127.0.0.1:8000/v1/runs \\\n  -H \"Content-Type: application/json\" \\\n  -d @examples/spec.json\n</code></pre> <p>The API exposes the same deterministic contracts as the CLI.</p>"},{"location":"#project-boundaries","title":"Project boundaries","text":"<p>bijux-rar is intentionally narrow in scope.</p> <p>It is not:</p> <ul> <li>a chat framework,</li> <li>a prompt playground,</li> <li>a generic RAG toolkit,</li> <li>an experimentation sandbox.</li> </ul> <p>It is a core execution and verification engine.</p>"},{"location":"#relationship-to-other-bijux-projects","title":"Relationship to other bijux projects","text":"<ul> <li> <p>bijux-cli \u2014 shared CLI conventions and scaffolding   https://github.com/bijux/bijux-cli</p> </li> <li> <p>bijux-rag \u2014 retrieval layer and corpus tooling   https://github.com/bijux/bijux-rag</p> </li> </ul> <p>bijux-rar sits beneath both, enforcing execution and verification invariants.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Authoritative documentation is published at:</p> <p>https://bijux.github.io/bijux-rar/</p> <p>The documentation is part of the system contract. Code and docs are tested for drift.</p>"},{"location":"#stability-and-compatibility","title":"Stability and compatibility","text":"<p>Initial public release: v0.1.0</p> <ul> <li>Core contracts are frozen.</li> <li>Breaking changes require explicit versioning and migration.</li> <li>Determinism and replay invariants will not be relaxed.</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT. See <code>LICENSE</code>.</p>"},{"location":"maintainer/forbidden_changes/","title":"forbidden_changes","text":""},{"location":"maintainer/forbidden_changes/#forbidden-changes","title":"Forbidden Changes","text":"<ul> <li>Changing event kinds or schemas without version bump + migrator.</li> <li>Allowing writes outside <code>artifacts/runs/&lt;run_id&gt;/</code>.</li> <li>Relaxing span+hash grounding or citation markers.</li> <li>Introducing non-deterministic behavior into replay or verification.</li> <li>Removing or altering invariant IDs without coordination.</li> <li>Never weakening determinism, replay, or verification guarantees for convenience.</li> <li>Breaking changes without version bump, migration plan, and doc update are rejected.</li> <li>Refactoring away manifest/provenance hashing or sealed trace semantics.***</li> </ul>"},{"location":"maintainer/glossary/","title":"glossary","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"maintainer/glossary/#glossary-hostile-precision","title":"Glossary (Hostile Precision)","text":"<ul> <li>Terms are locked; adding or changing definitions requires a formal version bump.</li> <li>Vocabulary is fixed; new words must be added here before appearing in specs.</li> <li>Verification: Checking structural/provenance invariants. Does not mean factual correctness. Does not mean semantic truth.</li> <li>Evidence: Chunked, hashed byte spans stored under artifacts. Does not include model output or summaries.</li> <li>Citation: <code>[evidence:&lt;id&gt;:&lt;b0&gt;-&lt;b1&gt;:&lt;sha256&gt;]</code> marker plus SupportRef. Anything else is rejected.</li> <li>Replay: Re-execution using pinned artifacts/config. Not log playback, not stochastic simulation.</li> <li>Insufficient Evidence: Explicit signal that required supports are absent. Not an error mask; verifier treats it as a distinct outcome.</li> <li>Undefined Behavior: Any state not covered by schemas/invariants; no guarantees are made and behavior may change without notice.</li> </ul> <p>Terminology Lock: - Definitions above are locked. Changing a definition is a breaking change and requires a major version bump with migration guidance.***</p>"},{"location":"maintainer/maintainer_rules/","title":"maintainer_rules","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"maintainer/maintainer_rules/#maintainer-rules","title":"Maintainer Rules","text":"<ul> <li>PRs that relax invariants (grounding, replay, determinism) are rejected.</li> <li>PRs that add new event kinds without schema/version bump are rejected.</li> <li>Refactors that add hidden state or global randomness are rejected.</li> <li>Doc PRs must obey <code>docs/doc_invariants.md</code>; violations are rejected.</li> <li>Non-deterministic features must be opt-in, recorded, and replayable; otherwise rejected.</li> <li>Mandatory gates (lint, test, quality, security, api) must pass before review.</li> <li>Changes that can fail determinism or replay must be redesigned or dropped.</li> <li>Elegance does not trump invariants; if in doubt, keep the invariant intact.***</li> </ul>"},{"location":"maintainer/project_tree/","title":"Project Tree","text":"<p>bijux-rar mirrors bijux-rag conventions.</p> <p>Repository guarantees: - <code>make all</code> runs real gates in CI. - Tests are collected (non-zero). - No filesystem pollution outside <code>artifacts/</code> and allowed tool caches. - Placeholder OpenAPI drift gate exists (non-authoritative until API implementation).</p>"},{"location":"maintainer/security_policy/","title":"Security","text":"<p>This document defines the explicit security model and threat boundaries of bijux-rar.</p> <p>Security properties outside this document are not guaranteed.</p> <p>Report vulnerabilities privately via GitHub Security Advisories. Do not open public issues for security concerns.</p>"},{"location":"maintainer/security_policy/#security-posture","title":"Security posture","text":"<p>bijux-rar is designed as a deterministic execution and verification engine, not a hardened multi-tenant service.</p> <p>Security controls are defensive, explicit, and scope-limited. If a behavior is not described here, it must be assumed unsafe.</p>"},{"location":"maintainer/security_policy/#trust-boundaries","title":"Trust boundaries","text":"<p>The following inputs are always untrusted:</p> <ul> <li>All HTTP request bodies, headers, query parameters, and paths</li> <li>Any trace, plan, artifact, or manifest loaded from disk</li> <li>Any corpus or evidence content supplied by the user</li> </ul> <p>The HTTP boundary is defined in <code>src/bijux_rar/httpapi.py</code>.</p> <p>All validation is fail-fast; malformed or suspicious input is rejected.</p>"},{"location":"maintainer/security_policy/#authentication","title":"Authentication","text":"<ul> <li>Optional API key authentication via header <code>X-API-Token</code></li> <li>Controlled by environment variable <code>RAR_API_TOKEN</code></li> <li>If unset, the API is explicitly unauthenticated</li> </ul> <p>There is no user model, role system, or identity management.</p>"},{"location":"maintainer/security_policy/#rate-limiting","title":"Rate limiting","text":"<ul> <li>Best-effort, per-process rate limiting</li> <li>Configured via <code>RAR_API_RATE_LIMIT</code> (requests per minute)</li> <li>No shared state, no distributed coordination</li> </ul> <p>Rate limiting is a protective measure, not an abuse-prevention guarantee.</p>"},{"location":"maintainer/security_policy/#resource-limits","title":"Resource limits","text":"<p>All runs are bounded by explicit quotas:</p> <ul> <li>Wall-clock time: <code>RAR_RUN_TIME_BUDGET_SEC</code></li> <li>CPU time (process clock): <code>RAR_RUN_CPU_BUDGET_SEC</code></li> <li>Disk usage per run: <code>RAR_RUN_DISK_QUOTA_BYTES</code></li> </ul> <p>Quota violations terminate execution immediately.</p>"},{"location":"maintainer/security_policy/#filesystem-and-path-safety","title":"Filesystem and path safety","text":"<ul> <li>All artifact paths are resolved under a single artifacts root</li> <li>Path traversal (<code>..</code>) is rejected</li> <li>Symlink escapes outside the artifacts root are rejected</li> <li>POSIX paths only</li> </ul> <p>No filesystem access outside the artifacts directory is permitted.</p>"},{"location":"maintainer/security_policy/#content-handling","title":"Content handling","text":"<ul> <li>Request size is capped (<code>MAX_REQUEST_BYTES</code> in <code>httpapi.py</code>)</li> <li>Only JSON media types are accepted</li> <li>XML and other structured formats are explicitly rejected</li> <li>Accept headers are enforced</li> </ul> <p>bijux-rar does not attempt to sanitize or interpret arbitrary user content.</p>"},{"location":"maintainer/security_policy/#artifact-integrity","title":"Artifact integrity","text":"<ul> <li>All core artifacts are hashed and recorded in manifests</li> <li>Evidence references include span + content hash validation</li> <li>Provenance is enforced during verification and replay</li> </ul> <p>Any hash mismatch causes verification failure.</p>"},{"location":"maintainer/security_policy/#replay-and-verification-guarantees","title":"Replay and verification guarantees","text":"<p>Replay and verification require:</p> <ul> <li>Byte-identical traces</li> <li>Matching artifact hashes</li> <li>Stable provenance identifiers</li> </ul> <p>If these conditions are not met, replay or verification fails.</p> <p>There is no partial or best-effort verification mode.</p>"},{"location":"maintainer/security_policy/#explicit-non-goals","title":"Explicit non-goals","text":"<p>The following are out of scope by design:</p> <ul> <li>Multi-tenant isolation beyond API key + rate limit</li> <li>TLS termination (must be handled by deployment environment)</li> <li>Secrets rotation or credential lifecycle management</li> <li>Sandboxing or execution of untrusted user code</li> <li>Defense against malicious local users</li> </ul> <p>If you need these properties, you must add them externally.</p>"},{"location":"maintainer/security_policy/#vulnerability-reporting","title":"Vulnerability reporting","text":"<p>If you discover a security issue:</p> <ul> <li>Do not open a public GitHub issue</li> <li>Use GitHub Security Advisories</li> <li>Or contact the maintainers privately</li> </ul> <p>Responsible disclosure is required.</p>"},{"location":"maintainer/tests/","title":"Tests","text":"<p>Tests are mandatory, required, and enforced; benchmarks accompany critical paths.</p> <p>All changes must pass the full test suite via <code>make all</code>. There is no partial, advisory, or best-effort testing mode.</p>"},{"location":"maintainer/tests/#scope","title":"Scope","text":"<p>The test suite covers the following guarantees:</p> <ul> <li>Determinism</li> <li>Planner output stability</li> <li>Executor ordering and topology enforcement</li> <li> <p>Cross-platform fingerprint stability</p> </li> <li> <p>Core invariants</p> </li> <li>Trace structure and ordering</li> <li>Artifact and manifest integrity</li> <li> <p>ID and hash stability</p> </li> <li> <p>Verification</p> </li> <li>Evidence span and hash validation</li> <li>Provenance enforcement</li> <li> <p>Verification failure modes</p> </li> <li> <p>Serialization</p> </li> <li>Canonical JSON encoding</li> <li>JSONL round-trip stability</li> <li> <p>Trace and artifact compatibility checks</p> </li> <li> <p>Runtime behavior</p> </li> <li>Frozen runtime determinism</li> <li>Tool invocation ordering</li> <li> <p>Replay safety and diff detection</p> </li> <li> <p>End-to-end gates</p> </li> <li>CLI smoke tests</li> <li>Deterministic replay (fingerprint + diff)</li> <li>HTTP API smoke and contract tests</li> </ul>"},{"location":"maintainer/tests/#enforcement","title":"Enforcement","text":"<ul> <li>Tests are executed automatically by CI</li> <li>Coverage is enforced for <code>src/bijux_rar</code></li> <li>Determinism and replay gates are non-optional</li> </ul> <p>A test failure indicates a contract violation.</p>"},{"location":"maintainer/tests/#running-locally","title":"Running locally","text":"<pre><code>make test\n````\n\nRuns the full pytest suite, including coverage and invariant checks.\n\n```bash\nmake replay_gate\n</code></pre> <p>Runs determinism-only replay and diff enforcement.</p>"},{"location":"maintainer/tests/#contribution-policy","title":"Contribution policy","text":"<p>Pull requests that:</p> <ul> <li>reduce coverage,</li> <li>weaken determinism,</li> <li>relax invariants,</li> <li>or bypass replay checks</li> </ul> <p>will be rejected.</p>"},{"location":"maintainer/tooling/","title":"Tooling","text":"<p>The project uses a fixed, enforced toolchain.</p> <p>All tools listed here are required. Changes that bypass or weaken this toolchain are not accepted.</p>"},{"location":"maintainer/tooling/#code-quality-and-correctness","title":"Code quality and correctness","text":"<ul> <li> <p>Ruff   Formatting and linting. Style deviations are rejected.</p> </li> <li> <p>MyPy and Pyright   Static typing and interface validation.</p> </li> </ul>"},{"location":"maintainer/tooling/#testing-and-coverage","title":"Testing and coverage","text":"<ul> <li> <p>Pytest and pytest-cov   Full test execution and coverage reporting.</p> </li> <li> <p>Coverage threshold   Enforced for <code>src/bijux_rar</code> (default: 85%).</p> </li> </ul>"},{"location":"maintainer/tooling/#security-and-supply-chain","title":"Security and supply chain","text":"<ul> <li> <p>pip-audit   Dependency vulnerability scanning.</p> </li> <li> <p>bandit   Static security analysis.</p> </li> <li> <p>cyclonedx-bom   Software Bill of Materials (SBOM) generation.</p> </li> </ul>"},{"location":"maintainer/tooling/#documentation","title":"Documentation","text":"<ul> <li>MkDocs   Documentation build and publication.</li> </ul> <p>Documentation is treated as part of the system contract.</p>"},{"location":"maintainer/tooling/#execution","title":"Execution","text":"<p>All tooling is executed via:</p> <pre><code>make all\n</code></pre>"},{"location":"maintainer/why_this_is_hard/","title":"why_this_is_hard","text":""},{"location":"maintainer/why_this_is_hard/#why-this-is-hard","title":"Why This Is Hard","text":"<ul> <li>Determinism is fragile: minor changes in ordering, hashing, or provenance break replay.</li> <li>Verification is expensive but necessary: soft checks invite drift and corruption.</li> <li>Shortcuts (e.g., skipping span+hash, loosening schemas) silently destroy auditability.</li> <li>Schema/version changes cascade: without migration, archives become unusable.</li> <li>Convenience features often undermine invariants; they are rejected by design.***</li> </ul>"},{"location":"maintainer/maintenance/design_review_template/","title":"Design review template","text":""},{"location":"maintainer/maintenance/design_review_template/#design-review-template","title":"Design Review Template","text":"<ul> <li>Which invariants (IDs) are affected?</li> <li>Which docs are updated? (list filenames)</li> <li>Which misuse cases could be reintroduced?</li> <li>Are schema versions touched? If yes, how is compatibility handled?</li> <li>Are replay/determinism guarantees impacted?</li> <li>What tests cover these changes?</li> </ul> <p>No answers \u2192 no merge.***</p>"},{"location":"maintainer/maintenance/doc_drift_detection/","title":"Doc drift detection","text":"<p>BREAKING_IF_CHANGED: true</p>"},{"location":"maintainer/maintenance/doc_drift_detection/#doc-drift-detection","title":"Doc Drift Detection","text":"<p>Rules: - If code under a module listed in <code>docs/doc_to_code_map.md</code> changes, the corresponding doc must be reviewed/updated or explicitly waived in the PR. - If a doc references a module/path, that module/path must exist. - STATUS headers, BREAKING_IF_CHANGED markers, and invariant IDs must remain intact.</p> <p>These rules are enforced via tests in <code>tests/unit/test_doc_drift.py</code>.***</p>"},{"location":"maintainer/maintenance/extension_points/","title":"Extension points","text":""},{"location":"maintainer/maintenance/extension_points/#extension-points-only-one","title":"Extension Points (Only One)","text":"<p>STATUS: EXPLANATORY</p> <p>Supported seam: ReasonerBackend</p>"},{"location":"maintainer/maintenance/extension_points/#how-to-implement","title":"How to implement","text":"<ul> <li>Implement <code>ReasonerBackend</code> interface in <code>src/bijux_rar/rar/reasoning/backend.py</code>.</li> <li>Produce <code>Derivation</code> objects with verifiable <code>citations</code> (span+hash).</li> <li>Register backend via configuration/preset, not globals.</li> </ul>"},{"location":"maintainer/maintenance/extension_points/#everything-else-is-closed","title":"Everything else is closed","text":"<ul> <li>No custom event types.</li> <li>No custom verification rules.</li> <li>No custom storage backends for core artifacts.</li> <li>No tool protocol changes.</li> </ul> <p>Rationale: limiting extension to reasoning keeps artifacts, verification, and replay stable.***</p>"},{"location":"maintainer/maintenance/issue_guidelines/","title":"Issue guidelines","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"maintainer/maintenance/issue_guidelines/#read-this-before-filing-an-issue","title":"Read This Before Filing an Issue","text":"<p>We will close issues immediately if: - You did not run <code>make all</code> and attach logs. - You request features that relax invariants (e.g., best-effort verification, legacy markers). - You ask for non-deterministic behavior without recorded artifacts.</p> <p>Required evidence for valid issues: - Command(s) run + full logs. - Trace/plan schema versions and fingerprints. - Description of whether artifacts under <code>artifacts/runs/&lt;run_id&gt;/</code> are intact.</p> <p>Check first: - Docs in <code>docs/start_here.md</code> and <code>docs/doc_invariants.md</code>. - Existing failure modes in <code>docs/SECURITY_FAILURE_MODES.md</code> and <code>docs/examples/invalid_traces.md</code>.</p> <p>If you disagree with the constraints, this is not the right project.***</p>"},{"location":"maintainer/maintenance/maintenance_guide/","title":"Maintenance guide","text":""},{"location":"maintainer/maintenance/maintenance_guide/#maintenance-extension-guide","title":"Maintenance &amp; Extension Guide","text":"<p>STATUS: EXPLANATORY</p> <p>Allowed: - Extend <code>ReasonerBackend</code> with deterministic outputs and verifiable citations. - Add new verification checks if they remain fail-closed and schema-aware. - Add metrics/eval outputs that derive from existing artifacts.</p> <p>Forbidden: - New event kinds without schema/version bump. - New write locations outside <code>artifacts/runs/&lt;run_id&gt;/</code>. - Relaxing grounding or replay invariants. - Adding runtime globals or hidden state.</p> <p>How to extend safely: - Preserve schemas and invariants; if a change is breaking, bump versions and provide migrators. - Keep replay deterministic; any new runtime behavior must be recordable and replayable. - Add tests that fail on invariant violations and mismatched fingerprints.</p>"},{"location":"maintainer/rationale/abstraction_rationale/","title":"Abstraction rationale","text":""},{"location":"maintainer/rationale/abstraction_rationale/#abstraction-rationale","title":"Abstraction Rationale","text":"<p>STATUS: EXPLANATORY</p> <p>Planner: - Rejected simpler \u201cinline steps\u201d because explicit plan DAG enables validation and replay ordering. Without it, dependency errors go undetected.</p> <p>Verifier: - Rejected \u201cbest-effort\u201d checks because fail-closed is required for auditability. Soft verification would allow silent corruption.</p> <p>FrozenRuntime: - Rejected \u201cre-run tools live\u201d for replay because determinism requires pinned outputs/config. Live replay would allow drift and tampering.</p> <p>ReasonerBackend: - Rejected ad-hoc reasoning code paths; a single extension seam keeps claims/citations verifiable and prevents arbitrary logic from bypassing grounding.</p>"},{"location":"maintainer/rationale/anti_goals/","title":"Anti goals","text":""},{"location":"maintainer/rationale/anti_goals/#what-bijux-rar-is-not","title":"What bijux-rar is NOT","text":"<p>STATUS: EXPLANATORY</p> <ul> <li>Not a chat framework.</li> <li>Not an LLM orchestration tool.</li> <li>Not a RAG optimizer or ranking library.</li> <li>Not user-friendly by default; prioritizes auditability over convenience.</li> <li>Not a general-purpose workflow engine; the pipeline is fixed and deterministic.</li> <li>Not responsible for hallucination detection beyond span+hash grounding.***</li> </ul>"},{"location":"maintainer/rationale/philosophy/","title":"Philosophy","text":""},{"location":"maintainer/rationale/philosophy/#philosophy","title":"Philosophy","text":"<p>STATUS: EXPLANATORY</p> <p>Evidence must be re-verified at the byte level or it is ignored. Replay outranks performance because reproducibility is the guard against drift and tampering. Claims without span+hash grounding are rejected. Auditability is a first-class goal; unverifiable behavior is treated as failure. Users must accept fixed constraints; otherwise, use something else.</p>"},{"location":"spec/","title":"bijux-rar","text":"<p>Deterministic, auditable reasoning runtime with structured plans, claims, evidence, verification, and replay. All artifacts are versioned, fingerprinted, and stored under <code>artifacts/</code>.</p>"},{"location":"spec/#normative-document-hierarchy","title":"Normative Document Hierarchy","text":"<p>If any documents conflict, authority is resolved in this order: 1. <code>core_contracts.md</code> 2. <code>trace_format.md</code> 3. <code>verification_model.md</code> 4. <code>determinism.md</code> 5. Everything else (explanatory only).</p>"},{"location":"spec/#read-order","title":"Read Order","text":"<p><code>read_this_first.md</code> \u2192 <code>mental_model.md</code> \u2192 <code>execution_flow.md</code> \u2192 <code>state_and_artifacts.md</code> \u2192 <code>trace_format.md</code> \u2192 <code>trace_lifecycle.md</code> \u2192 <code>core_contracts.md</code> \u2192 <code>determinism.md</code> \u2192 <code>verification_model.md</code> \u2192 security/versioning.***</p>"},{"location":"spec/architecture/","title":"Architecture","text":""},{"location":"spec/architecture/#contracts","title":"Contracts","text":"<ul> <li>Deterministic, content-addressed IDs (no UUID defaults)</li> <li>Canonical JSON + SHA256 fingerprints</li> <li>Pure invariants returning error lists</li> <li>Deterministic Trace JSONL serialization (header + event records)</li> </ul>"},{"location":"spec/architecture/#planner-pure","title":"Planner (pure)","text":"<p><code>ProblemSpec -&gt; Plan</code> with deterministic decomposition: <code>understand -&gt; gather -&gt; derive -&gt; verify -&gt; finalize</code>. The flow is linear and acyclic; backedges are invalid.</p> <p>Planner stores a structured <code>StepSpec</code> on each <code>PlanNode</code> (no free-form dict payloads).</p>"},{"location":"spec/architecture/#executor-effectful-deterministic","title":"Executor (effectful, deterministic)","text":"<p><code>Plan + Runtime -&gt; Trace</code>: - stable topological traversal - emits structured trace events - executes tool calls via a ToolRegistry - emits structured claims and evidence registrations</p> <p>No timestamps, no UUIDs, no environment dependence.</p>"},{"location":"spec/architecture/#verification","title":"Verification","text":"<p><code>verify_trace(trace, plan)</code> is pure and produces a deterministic <code>VerificationReport</code>.</p> <p>Checks include: - core invariants (plan + trace) - step completeness (required kinds, finished steps) - tool linkage (tool_called must have tool_returned) - claim support refs must resolve to known ids - grounding check if evidence exists</p>"},{"location":"spec/architecture/#replay-and-diff","title":"Replay and Diff","text":"<p><code>replay_from_artifacts</code> re-runs a trace with the recorded spec/seed/runtime descriptor, writes a replay trace, and reports fingerprint and structural diffs for drift gating.</p> <p>Back to top</p>"},{"location":"spec/benchmarks/","title":"Benchmark reproducibility","text":"<ul> <li>Benchmarks run via <code>pytest-benchmark</code>; results stored under <code>artifacts/test/benchmarks</code>.</li> <li>Use the same Python version and dependencies (see <code>pyproject.toml</code>) to compare runs.</li> <li>Do not compare benchmarks across machines unless normalized by CPU; instead, use the regression thresholds enforced in <code>tests/perf/test_retrieval_benchmark.py</code>.</li> <li>Always run with <code>PYTHONDONTWRITEBYTECODE=1</code> to avoid filesystem noise.</li> </ul>"},{"location":"spec/core_contracts/","title":"core_contracts","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"spec/core_contracts/#core-contract-immutable-normative","title":"Core Contract (Immutable, Normative)","text":"<p> Authoritative for: system-wide contracts and invariants Non-authoritative for: trace schema details (see trace_format.md) STATUS: AUTHORITATIVE</p> <p>Rules (numbered, MUST/SHALL only): 1. A run MUST emit <code>trace.jsonl</code> with strictly increasing <code>idx</code>; any rewrite or reorder invalidates the run. 2. Every derived claim MUST cite evidence using <code>[evidence:&lt;id&gt;:&lt;b0&gt;-&lt;b1&gt;:&lt;sha256&gt;]</code> computed over exact evidence bytes; missing/mismatched hashes SHALL be rejected. 3. Replay MUST reproduce fingerprints when corpus/index/provenance match; fingerprint drift SHALL fail the run. 4. All artifacts SHALL live under <code>artifacts/runs/&lt;run_id&gt;/</code>; writes elsewhere are forbidden. 5. Trace/plan/manifest MUST carry supported schema versions; unknown versions SHALL be rejected unless an explicit upgrader exists. 6. Any invariant violation (span bounds, missing evidence, unknown tool, hash mismatch) SHALL hard-fail verification; no soft modes exist.</p> <p>Out of Scope (non-goals, binding): - Best-effort verification is not provided. - Legacy citation markers (<code>[evidence:X]</code>) are not accepted. - Implicit network/LLM calls during replay are not allowed. - Wall-clock time or locale SHALL NOT influence determinism.</p> <p>Breaking Changes Policy: - Minor releases MAY add backward-compatible fields. - Major releases MAY change schemas or invariants; such changes REQUIRE a migrator or explicit rejection path.</p> <p>Misuse Examples: - Citing whole documents instead of chunks \u2192 rejected for missing chunk alignment. - Editing evidence after manifest generation \u2192 hash mismatch triggers hard failure. - Injecting extra events into <code>trace.jsonl</code> \u2192 schema/invariant validation rejects the run.</p> <p>What Breaks if You Change This: - Relaxing span+hash grounding destroys replay/verifier integrity. - Allowing root writes pollutes the audit trail; artifacts become untrusted. - Accepting legacy markers reintroduces unverifiable claims; grounding collapses.</p> <p>Non-Negotiable Invariants: - Trace immutability is enforced; edits invalidate runs. - Span+hash grounding is mandatory for derived claims. - Artifacts must live under <code>artifacts/runs/&lt;run_id&gt;/</code>. - Only supported schema versions are accepted; unknown versions are rejected.</p> <p>Rejected Alternatives: - Allowing best-effort verification \u2192 rejected because it permits silent corruption and breaks auditability. - Accepting legacy markers \u2192 rejected because citations become unverifiable. - Allowing writes outside artifacts/ \u2192 rejected because provenance and determinism would be unenforceable.</p> <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT define lifecycle states; see trace_lifecycle.md. - Does NOT define verifier policies; see verification_model.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - Which behaviors invalidate a run immediately. - Where artifacts must live and why. - How schema version mismatches are handled.***</p> <p>Back to top</p>"},{"location":"spec/determinism/","title":"determinism","text":""},{"location":"spec/determinism/#determinism-guarantees","title":"Determinism Guarantees","text":"<p>STATUS: AUTHORITATIVE</p> <p>Guaranteed deterministic: - Fingerprints (sha256 over canonical bytes). - Trace event ordering and IDs (stable_id). - Chunking (UTF-8 byte spans, fixed params). - BM25 ranking (rounded scores, doc-id tiebreak).</p> <p>Conditionally deterministic: - Execution with identical corpus/index/provenance and runtime config. - Reasoner when backend is deterministic; LLM backends are opt-in and non-deterministic.</p> <p>Not deterministic: - Any external network/LLM call unless frozen and replayed. - Host-level nondeterminism outside artifacts (e.g., filesystem reordering).</p> <p>Environment assumptions: - POSIX-style paths recorded; symlinks resolved strictly. - Locale-independent tokenization; stable float rounding. - Hashing algorithm fixed to sha256.</p> <p>Undefined behavior: - Running with missing provenance or altered artifacts.</p>"},{"location":"spec/determinism/#determinism-matrix","title":"Determinism Matrix","text":"Component Deterministic Conditions Notes Fingerprints Yes Canonical bytes + sha256 Changes in canonicalization_version break Trace event order/IDs Yes Stable plan + execution path Reordering or mutation invalidates run Chunking Yes UTF-8 spans, fixed chunk/overlap params Locale/time do not affect chunking BM25 ranking Yes Same corpus/index, score rounding, doc-id tiebreak Float drift mitigated via rounding Replay Yes Provenance hashes match; artifacts intact Drift \u2192 failure Reasoner (deterministic) Yes Deterministic backend only LLM/non-deterministic backends are opt-in External tools No Unless frozen outputs recorded Live calls break determinism <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT define verifier policies; see verification_model.md. - Does NOT define lifecycle states; see trace_lifecycle.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - Which components are deterministic vs conditional vs non-deterministic. - What conditions are required for replay to be deterministic. - How environment assumptions (locale, hashing, paths) affect determinism.***</p>"},{"location":"spec/doc_dependency/","title":"doc_dependency","text":""},{"location":"spec/doc_dependency/#documentation-dependency-graph","title":"Documentation Dependency Graph","text":"<ul> <li>start_here.md -&gt; []</li> <li>read_this_first.md -&gt; []</li> <li>mental_model.md -&gt; read_this_first.md</li> <li>execution_flow.md -&gt; mental_model.md</li> <li>state_and_artifacts.md -&gt; execution_flow.md</li> <li>trace_format.md -&gt; state_and_artifacts.md</li> <li>trace_lifecycle.md -&gt; trace_format.md</li> <li>core_contracts.md -&gt; trace_lifecycle.md</li> <li>system_contract.md -&gt; core_contracts.md</li> <li>determinism.md -&gt; core_contracts.md</li> <li>verification_model.md -&gt; core_contracts.md, trace_format.md</li> <li>failure_semantics.md -&gt; verification_model.md</li> <li>security_model.md -&gt; core_contracts.md</li> <li>versioning_compat.md -&gt; core_contracts.md</li> <li>release_scope_v0_1_0.md -&gt; system_contract.md</li> <li>architecture.md -&gt; execution_flow.md</li> <li>benchmarks.md -&gt; architecture.md</li> <li>misuse_cases.md -&gt; core_contracts.md</li> <li>doc_invariants.md -&gt; system_contract.md</li> <li>doc_to_code_map.md -&gt; doc_invariants.md</li> <li>maintainer_rules.md -&gt; doc_invariants.md</li> <li>contributor_reading_order.md -&gt; doc_invariants.md</li> </ul>"},{"location":"spec/doc_invariants/","title":"doc_invariants","text":""},{"location":"spec/doc_invariants/#documentation-invariants","title":"Documentation Invariants","text":"<p>STATUS: AUTHORITATIVE</p> <ul> <li>One concept per file; no duplicates.</li> <li>Each core doc states scope, non-goals, and non-negotiable invariants.</li> <li>Every contract names how it can be violated.</li> <li>Examples must reference concrete artifacts (paths, fingerprints, outputs).</li> <li>Forward links only; no backward references that create circular reading.</li> <li>Any new invariant must name its failure mode.</li> <li>Docs are invalid if they drift from code constants or schemas.***</li> <li>Soft language is banned from core docs and is grounds for rejection.</li> <li>Any Markdown file with three or more top-level sections must include a <code>&lt;a id=\"top\"&gt;&lt;/a&gt;</code> anchor near the top and a <code>[Back to top](#top)</code> link at the end.</li> <li>Docs directory layout (user/, spec/, maintainer/) is frozen for v0.1.x; adding new top-level categories requires a version bump and migration note.</li> </ul>"},{"location":"spec/doc_to_code_map/","title":"doc_to_code_map","text":""},{"location":"spec/doc_to_code_map/#doc-code-map-authority","title":"Doc \u2192 Code Map (Authority)","text":"<ul> <li><code>trace_format.md</code> \u2192 governs <code>src/bijux_rar/core/rar_types.py</code>, <code>boundaries/serde/trace_jsonl.py</code>, <code>rar/verification/checks.py</code> (schema fields, event validation). Doc supersedes code comments.</li> <li><code>trace_lifecycle.md</code> \u2192 governs trace emission/consumption (<code>rar/execution/executor.py</code>, <code>rar/traces/replay.py</code>). Doc supersedes code comments for lifecycle state.</li> <li><code>core_contracts.md</code> \u2192 governs system-wide invariants across execution/verification/replay. Doc supersedes code comments.</li> <li><code>determinism.md</code> \u2192 governs deterministic behavior (<code>rar/retrieval/*</code>, <code>rar/execution/runtime.py</code>, <code>core/fingerprints.py</code>). Doc supersedes code comments.</li> <li><code>verification_model.md</code> \u2192 governs verifier guarantees (<code>rar/verification/*</code>). Doc supersedes code comments.</li> <li><code>security_model.md</code> \u2192 governs security posture (<code>security.py</code>, <code>httpapi.py</code>, path validation). Doc supersedes code comments.</li> <li><code>versioning_compat.md</code> \u2192 governs schema/version compatibility logic. Doc supersedes code comments.</li> </ul> <p>If code and these docs disagree, docs are authoritative and code must be fixed.***</p>"},{"location":"spec/execution_flow/","title":"execution_flow","text":""},{"location":"spec/execution_flow/#execution-flow-single-pass","title":"Execution Flow (Single Pass)","text":"<p>STATUS: EXPLANATORY</p> <p>Linear path, no branches: <code>ProblemSpec \u2192 plan (Understand\u2192Gather\u2192Derive\u2192Verify\u2192Finalize) \u2192 trace.jsonl \u2192 verification \u2192 replay</code></p> <p>You understand this document if and only if you can answer: - The single permitted execution cycle. - Where trace is produced and consumed. - Where mutation stops and replay begins.***</p> <p>Step inputs/outputs: - ProblemSpec in \u2192 Plan (DAG) out. - Plan + runtime \u2192 Trace (ordered events) out. - Trace + Plan \u2192 VerificationReport out. - Trace + provenance \u2192 ReplayResult out.</p> <p>Immutability points: - Trace is mutable only while emitted; once written, any edit invalidates the run. - Verification and replay read-only consume artifacts; no mutation allowed.</p> <p>Undefined behavior: - Any deviation from this flow (e.g., Derive before Gather) is rejected or invalidates the run.</p>"},{"location":"spec/failure_semantics/","title":"failure_semantics","text":""},{"location":"spec/failure_semantics/#failure-semantics","title":"Failure Semantics","text":"<p>STATUS: AUTHORITATIVE</p> <p>Classes: - Validation failures: schema or invariant errors \u2192 fatal, user error. - Verification failures: span/hash mismatch, linkage errors \u2192 fatal, user error. - Replay failures: fingerprint drift, provenance mismatch \u2192 fatal, system integrity check. - IO failures: missing files, permission errors \u2192 fatal until resolved. - Misuse: forbidden flow, root pollution, unpinned corpus \u2192 fatal; run invalidated.</p> <p>Recoverable vs fatal: - Any failure above is fatal for the run; restart with corrected inputs/artifacts.</p> <p>Undefined behavior: - Ignoring failures or forcing continuation; system makes no guarantees.</p> <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT cover verifier policies; see verification_model.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - Which failures are fatal vs out of scope. - How misuse is classified. - Why no failure is recoverable without rerun.***</p>"},{"location":"spec/invariant_ids/","title":"invariant_ids","text":""},{"location":"spec/invariant_ids/#invariant-ids","title":"Invariant IDs","text":"<ul> <li>INV-DET-001: Trace replay MUST reproduce fingerprints when corpus/index/provenance match.</li> <li>INV-GRD-001: Derived claims MUST cite evidence via <code>[evidence:&lt;id&gt;:&lt;b0&gt;-&lt;b1&gt;:&lt;sha256&gt;]</code>; hashes over evidence bytes.</li> <li>INV-ART-001: All artifacts MUST reside under <code>artifacts/runs/&lt;run_id&gt;/</code>; root writes are forbidden.</li> <li>INV-SCH-001: Only supported schema versions MAY be consumed; unknown versions are rejected.</li> <li>INV-ORD-001: Trace events MUST be strictly ordered by <code>idx</code> and plan dependencies.</li> <li>INV-LNK-001: Every <code>tool_returned</code> MUST have a matching <code>tool_called</code>; linkage failures invalidate the run.***</li> </ul>"},{"location":"spec/lockfile/","title":"Lockfile policy","text":"<ul> <li><code>requirements.lock</code> is generated via <code>pip freeze</code> from the current dev environment to make installs reproducible.</li> <li>Regenerate after dependency changes: <code>pip freeze &gt; requirements.lock</code> in a clean venv.</li> <li>Consumers should prefer <code>pip install -r requirements.lock</code> to avoid drift when validating reproducibility or security.</li> </ul>"},{"location":"spec/mental_model/","title":"mental_model","text":""},{"location":"spec/mental_model/#minimal-mental-model","title":"Minimal Mental Model","text":"<p>STATUS: EXPLANATORY</p> <ul> <li>bijux-rar is a pipeline that turns a problem statement into a verified trace of reasoning steps.</li> <li>Each step emits structured events; nothing is free-form text that bypasses checks.</li> <li>Evidence is chunked, hashed, and cited by byte span. Claims must point to those spans.</li> <li>Verification replays the trace logic against artifacts and fails closed on any mismatch.</li> <li>Replay guarantees: with the same artifacts and config, fingerprints are identical.</li> </ul> <p>Audience: skeptical practitioners who need auditable reasoning, not convenience.***</p>"},{"location":"spec/misuse_cases/","title":"misuse_cases","text":""},{"location":"spec/misuse_cases/#misuse-cases-gallery","title":"Misuse Cases (Gallery)","text":"<p>STATUS: EXPLANATORY</p> <ul> <li>Partial evidence reuse: citing spans from a different corpus snapshot \u2192 provenance mismatch; verification fails.</li> <li>Span shifting: altering cited spans to different offsets \u2192 span/hash mismatch; claim rejected.</li> <li>Replay with modified artifacts: change evidence or manifest \u2192 replay refuses or fingerprint drift triggers failure.</li> <li>Fake tool outputs: tool_returned without matching tool_called \u2192 verifier rejects due to linkage failure.</li> <li>Version spoofing: bump trace_schema_version without migration \u2192 trace rejected outright.</li> </ul>"},{"location":"spec/read_this_first/","title":"read_this_first","text":""},{"location":"spec/read_this_first/#read-this-before-using-bijux-rar","title":"Read This Before Using bijux-rar","text":"<p>STATUS: EXPLANATORY \u2190 Back to index</p> <p>Who: audit-focused engineers willing to accept constraints. Not for casual prototyping.</p> <p>bijux-rar enforces byte-level evidence grounding, fails closed on any invariant violation, and refuses to run without pinned artifacts. Casual or exploratory use will feel hostile. If you cannot accept span+hash citations, deterministic replay, and fixed pipelines, stop here. If you proceed, you accept that convenience is sacrificed for auditability and that misuse results in rejection, not warnings.</p> <p>Next: mental_model.md Previous: index.md</p>"},{"location":"spec/release_scope_v0_1_0/","title":"release_scope_v0_1_0","text":""},{"location":"spec/release_scope_v0_1_0/#release-scope-v010","title":"Release Scope \u2014 v0.1.0","text":"<p>STATUS: AUTHORITATIVE</p> <p>This document freezes the scope for v0.1.0. No new features are accepted after this point\u2014only bug fixes and documentation clarifications.</p>"},{"location":"spec/release_scope_v0_1_0/#guaranteed-stable-in-v0x","title":"Guaranteed (stable in v0.x)","text":"<ul> <li>Deterministic trace, replay, and verification invariants (see system_contract.md and core_contracts.md).</li> <li>CLI surface: <code>init</code>, <code>run</code>, <code>verify</code>, <code>replay</code>, <code>eval</code> commands and their documented flags.</li> <li>Trace schema version and fingerprinting rules.</li> <li>Public Python imports under <code>bijux_rar.*</code> already documented in doc_to_code_map.md.</li> </ul>"},{"location":"spec/release_scope_v0_1_0/#experimental-may-change-within-v0x","title":"Experimental (may change within v0.x)","text":"<ul> <li>Evaluation metrics taxonomy (metrics names may expand).</li> <li>Benchmark harness outputs and thresholds.</li> <li>Optional extras in <code>pyproject.toml</code> (extras API surface may evolve).</li> </ul>"},{"location":"spec/release_scope_v0_1_0/#explicitly-excluded-not-supported-in-v010","title":"Explicitly Excluded (not supported in v0.1.0)","text":"<ul> <li>Non-deterministic reasoning backends enabled by default (LLM is opt-in and frozen).</li> <li>Hybrid retrieval backends (only the shipped deterministic chunked BM25 is supported).</li> <li>Breaking changes to verification leniency modes (only documented policies apply).</li> </ul>"},{"location":"spec/release_scope_v0_1_0/#may-break-before-v10-with-notice","title":"May Break Before v1.0 (with notice)","text":"<ul> <li>Internal file layout inside <code>artifacts/</code> but not the mandatory contract files (<code>spec.json</code>, <code>plan.json</code>, <code>trace.jsonl</code>, <code>verify.json</code>, <code>manifest.json</code>, provenance snapshots).</li> <li>Additional CLI flags marked experimental in help text.</li> <li>Optional dependency versions and extras composition.</li> </ul>"},{"location":"spec/security_failure_modes/","title":"security_failure_modes","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"spec/security_failure_modes/#security-failure-modes-cheat-sheet","title":"Security Failure Modes (Cheat Sheet)","text":"<ul> <li>Tamper evidence bytes: Detected (span hash mismatch) \u2192 hard fail.</li> <li>Delete/alter evidence files: Detected (manifest/hash mismatch) \u2192 hard fail.</li> <li>Use wrong corpus/index for replay: Detected (provenance hash mismatch) \u2192 replay refused.</li> <li>Unknown schema versions: Detected \u2192 trace rejected.</li> <li>Path traversal in evidence: Detected via path validation \u2192 rejected.</li> <li>Networked tools without recording: Out of scope; deterministic replay requires recorded outputs.</li> <li>Host compromise: Out of scope; assumes trusted host.</li> <li>Side-channel attacks: Out of scope; not mitigated.</li> </ul> <p>If any of the \u201cout of scope\u201d attacks succeed, the system makes no guarantees.***</p>"},{"location":"spec/security_model/","title":"security_model","text":""},{"location":"spec/security_model/#security-model","title":"Security Model","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"spec/security_model/#defended-threats","title":"Defended threats","text":"<ul> <li>Trace tampering: Span+hash verification on evidence bytes; manifest hashing; fail-closed verifier.</li> <li>Path traversal: Symlink-safe resolution; relative POSIX paths enforced.</li> <li>Replay integrity: Corpus/index provenance pinned; mismatches fail.</li> <li>API abuse: API key + rate limiting; request/response size limits; denylisted content types.</li> <li>Artifact pollution: No root writes; artifacts confined to <code>artifacts/</code>.</li> </ul>"},{"location":"spec/security_model/#not-defended-by-design","title":"Not Defended (by design)","text":"<ul> <li>Untrusted plugins: Only ReasonerBackend is supported; others are rejected.</li> <li>Side-channel leaks: Timing and resource exhaustion beyond quotas are not mitigated.</li> <li>Host compromise: Assumes runtime host is trusted.</li> <li>LLM/model risks: Non-deterministic backends are opt-in and not enabled in CI.</li> </ul>"},{"location":"spec/security_model/#trust-boundaries","title":"Trust Boundaries","text":"<ul> <li>Filesystem: only <code>artifacts/</code> is writable; evidence paths are validated.</li> <li>Network: runtimes are deterministic; external calls are treated as tools, recorded, and replayed from artifacts when frozen.</li> <li>API: authenticated via header; per-key rate limit; size limits enforced pre-handler.</li> </ul>"},{"location":"spec/security_model/#replay-as-a-security-feature","title":"Replay as a Security Feature","text":"<ul> <li>Replay validates that the same inputs/artifacts produce the same trace fingerprint, making tampering or drift detectable.</li> </ul>"},{"location":"spec/security_model/#explicit-boundaries-merged-from-security-boundaries","title":"Explicit Boundaries (merged from security boundaries)","text":"<ul> <li>Defended: path traversal, trace/evidence tampering, replay drift, API abuse (token, rate limit, size, denylist).</li> <li>Not defended: host compromise, side channels, untrusted plugins beyond ReasonerBackend, non-deterministic LLM behavior (unless frozen/replayed).</li> <li>Trust assumptions: artifacts/ is the only writable root; ProblemSpecs are not sanitized beyond invariants; locale/time do not affect determinism.</li> <li>Undefined behavior: missing/altered artifacts; networked tools without recorded outputs for replay.</li> </ul>"},{"location":"spec/security_model/#what-is-not-guaranteed","title":"What is NOT guaranteed","text":"<ul> <li>No promise of confidentiality beyond documented denylists and quotas.</li> <li>No guarantee of availability under resource exhaustion or hostile clients.</li> <li>No support for arbitrary plugins/tools outside documented extension points.</li> <li>Backward compatibility beyond the stated versioning policy is not promised.</li> </ul> <p>Scope Closure: - Does NOT restate verifier policies; see verification_model.md. - Does NOT define trace schema; see trace_format.md. - Does NOT cover lifecycle states; see trace_lifecycle.md.</p> <p>BREAKING_IF_CHANGED: true***</p>"},{"location":"spec/state_and_artifacts/","title":"state_and_artifacts","text":""},{"location":"spec/state_and_artifacts/#state-vs-artifacts-vs-derivations","title":"State vs Artifacts vs Derivations","text":"<p>STATUS: EXPLANATORY</p> <p>Runtime State: - Lives in process memory (planner, executor, runtime buckets). - Mutable during execution only. - Discarded after run; not relied on for replay.</p> <p>Persistent Artifacts: - Stored under <code>artifacts/runs/&lt;run_id&gt;/</code>. - Immutable after creation; mutation invalidates run. - Includes corpus snapshot, index, trace, manifest, provenance, verification.</p> <p>Derived Values: - Calculated from artifacts (fingerprints, metrics, replay results). - Must be reproducible from artifacts alone. - Not stored as authoritative sources; artifacts are.</p> <p>Replay expectations: - Only artifacts are trusted inputs to replay. - Runtime state is recreated; derivations must match or replay fails.</p> <p>Undefined behavior: - Using any external state or missing artifacts during replay.</p> <p>You understand this document if and only if you can answer: - Which data is runtime state vs artifact vs derivation. - Which parts are mutable and when. - What replay is allowed to consume.***</p>"},{"location":"spec/system_contract/","title":"system_contract","text":""},{"location":"spec/system_contract/#system-contract-one-page-normative","title":"System Contract (One Page, Normative)","text":"<p> STATUS: AUTHORITATIVE \u2190 Back to index</p> <ul> <li>Determinism: fingerprints, chunking, plan execution, and replay are deterministic given pinned corpus/index/provenance; drift fails the run.</li> <li>Evidence: all claims MUST cite evidence via span+hash markers; hashes computed over evidence bytes; mismatches are hard failures.</li> <li>Replay: consumes sealed artifacts only; provenance hashes must match; any drift or missing artifact refuses replay.</li> <li>Verification: fail-closed; schema/version mismatches, linkage failures, or hash/spans mismatches invalidate the run.</li> <li>Failure: any invariant violation invalidates the run; no soft modes.</li> </ul> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - How determinism, evidence grounding, replay, and verification interact. - What happens on any invariant violation. - What artifacts are mandatory for a valid run.***</p>"},{"location":"spec/system_contract/#what-is-not-guaranteed","title":"What is NOT guaranteed","text":"<ul> <li>Performance characteristics beyond documented benchmarks.</li> <li>Backward compatibility with trace/schema versions before v0.1.0.</li> <li>Acceptance of partially-grounded claims or probabilistic outputs.</li> <li>Support for unpinned or external artifacts during replay.</li> </ul> <p>Next: versioning_compat.md Previous: core_contracts.md</p> <p>Back to top</p>"},{"location":"spec/trace_format/","title":"Trace Format (Authoritative Spec)","text":"<p> Authoritative for: trace schema, required fields, rejection rules Non-authoritative for: execution flow, verification policies</p>"},{"location":"spec/trace_format/#versions","title":"Versions","text":"<ul> <li><code>trace_schema_version</code>: integer, currently 1</li> <li><code>fingerprint_algo</code>: <code>sha256</code></li> <li><code>canonicalization_version</code>: 1</li> </ul>"},{"location":"spec/trace_format/#event-types-exact-list","title":"Event Types (exact list)","text":"<ul> <li><code>step_started</code> {step_id}</li> <li><code>tool_called</code> {step_id, call}</li> <li><code>tool_returned</code> {step_id, result}</li> <li><code>evidence_registered</code> {step_id, evidence}</li> <li><code>claim_emitted</code> {step_id, claim}</li> <li><code>step_finished</code> {step_id, output}</li> </ul>"},{"location":"spec/trace_format/#required-fields","title":"Required Fields","text":"<ul> <li>Every event has <code>idx</code>, <code>kind</code>.</li> <li><code>call.id</code> and <code>result.call_id</code> must match.</li> <li><code>evidence</code> MUST include <code>id</code>, <code>uri</code>, <code>span</code>, <code>sha256</code>, <code>content_path</code>, <code>chunk_id</code>.</li> <li><code>claim</code> MUST include <code>supports</code> with <code>span</code> and <code>snippet_sha256</code>.</li> <li><code>output</code> is discriminated union (<code>understand</code>, <code>gather</code>, <code>derive</code>, <code>verify</code>, <code>finalize</code>, <code>insufficient</code>).</li> </ul>"},{"location":"spec/trace_format/#ordering","title":"Ordering","text":"<ul> <li>Strictly increasing <code>idx</code>.</li> <li>Topological w.r.t. plan dependencies.</li> </ul>"},{"location":"spec/trace_format/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>New optional fields MAY be added with default behavior.</li> <li>Removing or renaming fields requires a schema-version bump and explicit upgrader.</li> </ul>"},{"location":"spec/trace_format/#rejection-rules","title":"Rejection Rules","text":"<ul> <li>Unknown event kinds.</li> <li>Missing required fields.</li> <li>Span outside evidence bytes.</li> <li>Hash mismatch between cited span and evidence.</li> <li>Mismatched <code>trace_schema_version</code>.</li> </ul>"},{"location":"spec/trace_format/#misuse-examples","title":"Misuse Examples","text":"<ul> <li>Adding custom event kinds \u2192 rejected as unknown schema.</li> <li>Omitting <code>chunk_id</code> or <code>content_path</code> in evidence \u2192 trace invalid.</li> <li>Using legacy markers without span+hash \u2192 derived claims rejected.</li> </ul>"},{"location":"spec/trace_format/#what-breaks-if-you-change-this","title":"What Breaks if You Change This","text":"<ul> <li>Allowing unknown event kinds breaks replay and verifier expectations.</li> <li>Dropping span+hash or chunk_id makes evidence unverifiable; grounding collapses.</li> <li>Allowing unordered events invalidates dependency checks and replay determinism.</li> </ul>"},{"location":"spec/trace_format/#non-negotiable-invariants","title":"Non-Negotiable Invariants","text":"<ul> <li>Event kinds are closed and versioned.</li> <li>Span+hash + chunk_id are mandatory for evidence.</li> <li>Strict event ordering by <code>idx</code> is required.</li> </ul>"},{"location":"spec/trace_format/#trace-as-a-legal-object","title":"Trace as a Legal Object","text":"<ul> <li>Valid trace: all required fields present; event kinds known; spans within evidence; hashes match; schema version supported.</li> <li>Invalid-but-parseable: JSONL can be read but invariants fail (e.g., span out of bounds, hash mismatch); verifier rejects.</li> <li>Rejected outright: unknown event kinds, missing mandatory fields, unsupported schema version; trace is not processed.</li> </ul> <p>This contract is violated if: - Any event deviates from the allowed kinds. - Spans or hashes do not match evidence bytes. - Schema version is not in the supported set.</p> <p>Scope Closure: - Does NOT cover lifecycle states (see trace_lifecycle.md). - Does NOT cover verifier policies (see verification_model.md). - Does NOT define replay semantics (see trace_lifecycle.md / determinism.md).</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - What makes a trace valid vs invalid vs rejected outright. - Which fields are mandatory for evidence and claims. - Which schema versions are accepted and what happens otherwise.***</p> <p>Back to top</p>"},{"location":"spec/trace_lifecycle/","title":"trace_lifecycle","text":""},{"location":"spec/trace_lifecycle/#trace-lifecycle-state-machine","title":"Trace Lifecycle (State Machine)","text":"<p>Authoritative for: lifecycle states of trace artifacts Non-authoritative for: trace schema fields STATUS: AUTHORITATIVE \u2190 Back to index</p> <p>States: - Creating: events appended in order during execution. - Sealed: trace.jsonl written; manifest hashes recorded. - Verified: verification report produced; no mutation allowed. - Replayed: replay result computed; relies on sealed artifacts.</p> <p>Transitions: - Creating \u2192 Sealed when execution completes writing trace and manifest. - Sealed \u2192 Verified when verifier runs; any mismatch = rejection. - Sealed/Verified \u2192 Replayed when replay runs; fingerprint drift = failure.</p> <p>Invalidation: - Any edit to trace or evidence after sealing invalidates the run. - Missing artifacts or schema-version mismatch causes rejection before verify/replay.</p> <p>Undefined behavior: - Appending events after sealing. - Reordering events. - Running verify/replay with partial artifacts.</p> <p>Non-Negotiable Invariants: - Trace is immutable after sealing. - Manifest hashes bind evidence to the trace. - Replay consumes sealed artifacts only.</p> <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT define verifier policies; see verification_model.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - When a trace is mutable vs sealed. - What invalidates a sealed trace.</p> <p>Next: core_contracts.md Previous: trace_format.md - How replay interacts with sealed artifacts.***</p>"},{"location":"spec/verification_model/","title":"verification_model","text":""},{"location":"spec/verification_model/#verifier-contract","title":"Verifier Contract","text":"<p>Authoritative for: verifier guarantees and failure modes Non-authoritative for: trace schema (see trace_format.md) STATUS: AUTHORITATIVE \u2190 Back to index</p>"},{"location":"spec/verification_model/#what-verification-means","title":"What Verification Means","text":"<ul> <li>Ensures trace + plan obey schemas and invariants.</li> <li>Confirms every derived claim is grounded by verifiable citations (span+hash).</li> <li>Confirms tool linkage, evidence integrity, ordering, and required steps.</li> <li>Emits explicit failure reasons with severities.</li> </ul>"},{"location":"spec/verification_model/#hard-failure-triggers","title":"Hard Failure Triggers","text":"<ul> <li>Missing or malformed events/fields.</li> <li>Citation marker missing or malformed.</li> <li>Span out of bounds or hash mismatch.</li> <li>Evidence file missing or hash mismatch.</li> <li>Tool call/result mismatch.</li> <li>Required steps absent.</li> <li>Plan/trace schema version mismatch.</li> </ul>"},{"location":"spec/verification_model/#insufficient-evidence","title":"Insufficient Evidence","text":"<ul> <li>If reasoning emits <code>InsufficientEvidenceOutput</code>, verification passes only when:</li> <li>No derived claims are emitted, OR</li> <li>All derived claims clearly marked insufficient (policy-driven).</li> </ul>"},{"location":"spec/verification_model/#not-promised","title":"Not Promised","text":"<ul> <li>No hallucination detection beyond span+hash grounding.</li> <li>No probabilistic guarantees.</li> <li>No acceptance of partial verification; failures are fail-closed.</li> </ul> <p>Next: failure_semantics.md Previous: determinism.md</p>"},{"location":"spec/verification_model/#outputs","title":"Outputs","text":"<ul> <li><code>VerificationReport</code> with <code>checks</code>, <code>failures</code>, <code>summary_metrics</code>.</li> <li>Failures are machine-actionable; no free-form prose is required for enforcement.</li> </ul>"},{"location":"spec/verification_model/#misuse-examples","title":"Misuse Examples","text":"<ul> <li>Treating verification as \u201canswer correctness\u201d \u2192 incorrect; verification enforces provenance and structure only.</li> <li>Skipping plan validation \u2192 rejected due to invariant failure.</li> <li>Omitting span+hash supports \u2192 derived claims are rejected.</li> </ul>"},{"location":"spec/verification_model/#what-breaks-if-you-change-this","title":"What Breaks if You Change This","text":"<ul> <li>Relaxing span/hash checks makes claims unverifiable; auditability collapses.</li> <li>Soft-fail verification permits silent corruption; replay guarantees die.</li> <li>Removing tool linkage checks creates phantom tool calls/results; trace integrity fails.</li> </ul>"},{"location":"spec/verification_model/#non-negotiable-invariants","title":"Non-Negotiable Invariants","text":"<ul> <li>Verification is fail-closed on any invariant violation.</li> <li>Span+hash grounding is mandatory.</li> <li>Tool linkage and schema validation are mandatory.</li> </ul> <p>Verifier Guarantees Matrix: | Guarantee                | Enforced | Failure Mode   | | ------------------------ | -------- | -------------- | | Span hash integrity      | Yes      | Hard fail      | | Event ordering           | Yes      | Reject trace   | | Missing evidence         | Yes      | Invalid run    | | Tool call/result linkage | Yes      | Invalid run    | | Schema version support   | Yes      | Reject trace   |</p> <p>Rejected Alternatives: - Soft verification with warnings \u2192 rejected; enables drift and silent corruption. - Accepting partial linkage \u2192 rejected; enables phantom tool calls. - Ignoring span bounds \u2192 rejected; breaks grounding.</p> <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT cover lifecycle states; see trace_lifecycle.md. - Does NOT define replay semantics; see determinism.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - Which failures cause verification to hard-fail. - How insufficient evidence is treated. - How schema/version and linkage violations are handled.***</p>"},{"location":"spec/versioning_compat/","title":"versioning_compat","text":""},{"location":"spec/versioning_compat/#versioning-compatibility","title":"Versioning &amp; Compatibility","text":"<p>STATUS: AUTHORITATIVE</p> <p>Breaking change definition: - Any schema field removal/rename. - Any invariant relaxation/tightening. - Any change to fingerprint canonicalization or hashing.</p> <p>Trace compatibility: - Supported <code>trace_schema_version</code> set is fixed in code. - Unknown versions are rejected unless an explicit upgrader is provided. - Older traces must be upgraded via documented migrators; otherwise rejected.</p> <p>Artifact longevity: - Artifacts are intended to be archivable; replay must succeed with pinned corpus/index/provenance and matching schema versions. - Changing canonicalization_version or fingerprint_algo breaks compatibility; requires major release and migrator.</p> <p>Undefined behavior: - Consuming traces/artifacts with mismatched versions without migration.</p> <p>Compatibility Promise Table: | Aspect                    | Never changes without major bump | May change with migration | May change anytime | | ------------------------- | -------------------------------- | ------------------------- | ------------------ | | Trace schema version set  | Yes                              | With explicit migrator    | No                 | | Fingerprint algorithm     | Yes                              | No                        | No                 | | Canonicalization version  | Yes                              | With explicit migrator    | No                 | | Optional fields (additive)| No                               | Yes                       | No                 | | Invariants                | Yes                              | With major bump           | No                 |</p> <p>Scope Closure: - Does NOT restate trace schema; see trace_format.md. - Does NOT define verifier behavior; see verification_model.md. - Does NOT define lifecycle; see trace_lifecycle.md.</p> <p>BREAKING_IF_CHANGED: true</p> <p>You understand this document if and only if you can answer: - What constitutes a breaking change. - How older traces are treated when schema versions differ. - Which aspects can change with/without migration.***</p>"},{"location":"spec/examples/end_to_end/","title":"End to end","text":""},{"location":"spec/examples/end_to_end/#minimal-end-to-end-example","title":"Minimal End-to-End Example","text":"<p>STATUS: EXPLANATORY</p> <p>Trace schema version: 1 (this example is valid for schema_version=1; newer versions require migration if fields change).</p> <p>Input: - ProblemSpec: \"What is Rust?\", preset: \"default\", seed: 0, corpus: tests/fixtures/corpus_small.jsonl</p> <p>Generated artifacts (under <code>artifacts/runs/&lt;run_id&gt;/</code>): - <code>spec.json</code>, <code>plan.json</code>, <code>trace.jsonl</code>, <code>manifest.json</code>, <code>verify.json</code>, <code>provenance/corpus.jsonl</code>, <code>provenance/index/bm25_index.json</code></p> <p>Trace snippet (claim event): - <code>claim_emitted</code> with statement containing <code>[evidence:&lt;id&gt;:&lt;b0&gt;-&lt;b1&gt;:&lt;sha256&gt;]</code></p> <p>Verification output: - <code>verify.json</code> with <code>failures: []</code>, checks all passed.</p> <p>Replay: - <code>replay/trace.jsonl</code> fingerprint matches original when corpus/index/provenance unchanged.</p> <p>What breaks if schema_version changes: - Trace fields may differ; replay/verify will reject until migrated. - Manifest/provenance hashes must be regenerated for the new schema.</p> <p>Broken run (intentional failure): - Delete one evidence file after manifest generation. - Run <code>bijux-rar verify --trace trace.jsonl --plan plan.json --fail-on-verify</code>. - Expected: verifier fails <code>support_span_hashes</code> with missing file/hash mismatch; run is invalid.***</p>"},{"location":"spec/examples/invalid_traces/","title":"Invalid traces","text":"<p>STATUS: EXPLANATORY</p>"},{"location":"spec/examples/invalid_traces/#invalid-trace-examples-misuse","title":"Invalid Trace Examples (Misuse)","text":"<ul> <li>Tampered hash: evidence bytes changed after manifest \u2192 span hash mismatch \u2192 verifier fails <code>check_support_spans</code>.</li> <li>Missing step: Derive emitted without Gather \u2192 dependency violated \u2192 trace rejected by invariants.</li> <li>Replay with wrong corpus: provenance hash mismatch \u2192 replay refuses to run.</li> <li>Version mismatch: <code>trace_schema_version</code> not supported \u2192 trace rejected outright.</li> </ul> <p>These are intentionally hostile cases; any acceptance is a bug.***</p>"},{"location":"user/contributor_reading_order/","title":"contributor_reading_order","text":"<p>STATUS: AUTHORITATIVE</p>"},{"location":"user/contributor_reading_order/#contributor-reading-order","title":"Contributor Reading Order","text":"<p>Read in this exact sequence before changing code: 1. <code>start_here.md</code> 2. <code>doc_invariants.md</code> 3. <code>06_CORE_CONTRACTS.md</code> 4. <code>04_TRACE_FORMAT.md</code> 5. <code>05_TRACE_LIFECYCLE.md</code> 6. <code>07_DETERMINISM.md</code> 7. <code>08_VERIFICATION_MODEL.md</code> 8. <code>10_SECURITY_MODEL.md</code> 9. <code>12_VERSIONING_COMPAT.md</code> 10. <code>doc_to_code_map.md</code></p> <p>Do not submit a PR if you cannot accept these constraints.***</p>"},{"location":"user/non_goals_subsystems/","title":"non_goals_subsystems","text":""},{"location":"user/non_goals_subsystems/#subsystem-non-goals","title":"Subsystem Non-Goals","text":"<p>STATUS: EXPLANATORY</p> <p>Retrieval: - Not optimized for massive corpora beyond BM25 chunking; no hybrid retrieval here. - No automatic reranking or dense embeddings.</p> <p>Reasoning: - Not optimizing for creativity or fluency; only verifiable citations. - No multi-model orchestration or prompt tinkering for quality.</p> <p>Verification: - Not proving factual correctness; only provenance/structure. - Not providing partial/soft checks or probabilistic acceptance.</p> <p>Execution: - Not optimizing for throughput or low latency; determinism and auditability take priority. - No concurrent/async execution paths that break ordering or determinism.***</p>"},{"location":"user/not_rag/","title":"not_rag","text":""},{"location":"user/not_rag/#why-bijux-rar-is-not-a-rag-framework","title":"Why bijux-rar Is NOT a RAG Framework","text":"<p>STATUS: EXPLANATORY</p> <ul> <li>Does not orchestrate LLMs, vector DBs, or retrieval pipelines; it enforces deterministic reasoning traces.</li> <li>Does not optimize ranking or retrieval quality; it only grounds claims via span+hash.</li> <li>Verification here is provenance and structure, not factual truth.</li> <li>Replay and determinism outrank flexibility; experimentation without grounding is out of scope.</li> <li>If you want flexible orchestration or chat workflows, use a RAG toolkit; bijux-rar will reject that use case.***</li> </ul>"},{"location":"user/python_support/","title":"Python support matrix","text":"<ul> <li>Supported: 3.11, 3.12, 3.13 (see classifiers in <code>pyproject.toml</code>).</li> <li>Minimum tested locally: 3.11 (CI should mirror).</li> <li>Not supported: 3.10 and below; 3.14+ builds may require newer native deps (pyo3, etc.).</li> </ul>"},{"location":"user/start_here/","title":"start_here","text":""},{"location":"user/start_here/#start-here-15-minutes","title":"START HERE (15 minutes)","text":"<p>STATUS: EXPLANATORY</p> <p>What this solves (2 min): - Produces verifiable reasoning traces: plans \u2192 evidence \u2192 claims \u2192 verification \u2192 replay with drift detection.</p> <p>What you must know first (5 min): - Read read_this_first.md (hostile gatekeeper). - Read mental_model.md (concept map, no code). - Read execution_flow.md (one linear pass).</p> <p>Exact reading order with time estimates (8 min): 1. state_and_artifacts.md (1 min) 2. trace_format.md (2 min) 3. trace_lifecycle.md (1 min) 4. core_contracts.md (2 min) 5. determinism.md (1 min) 6. verification_model.md (1 min)</p> <p>If you disagree with these constraints, stop here. This system is not for you.</p> <p>Do NOT continue unless you accept span+hash grounding, deterministic replay, and fail-closed verification.***</p>"},{"location":"user/start_here/#what-is-not-guaranteed","title":"What is NOT guaranteed","text":"<ul> <li>Performance beyond documented benchmarks.</li> <li>Compatibility with undocumented runtimes or tooling.</li> <li>Acceptance of partial artifacts or ungrounded claims.</li> <li>Support for improvisational workflows outside the documented pipeline.</li> </ul>"},{"location":"user/usage/","title":"Usage","text":"<p>CLI commands are the primary entrypoints for deterministic runs. Run the deterministic pipeline:</p> <pre><code>python -m bijux_rar run --spec path/to/spec.json --seed 42 --preset default\n</code></pre> <p>Verify a trace (optional plan tightens checks):</p> <pre><code>python -m bijux_rar verify --trace artifacts/runs/&lt;run_id&gt;/trace.jsonl --plan artifacts/runs/&lt;run_id&gt;/plan.json\n</code></pre> <p>Replay with drift detection:</p> <pre><code>python -m bijux_rar replay --trace artifacts/runs/&lt;run_id&gt;/trace.jsonl\n</code></pre> <p>Determinism gate:</p> <pre><code>make replay_gate\n</code></pre>"}]}